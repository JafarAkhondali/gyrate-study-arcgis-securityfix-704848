(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-43384cda"],{"18c6":function(e,t,i){"use strict";i.d(t,"a",(function(){return A})),i.d(t,"b",(function(){return D})),i.d(t,"c",(function(){return P})),i.d(t,"d",(function(){return O})),i.d(t,"e",(function(){return I})),i.d(t,"f",(function(){return E})),i.d(t,"g",(function(){return x})),i.d(t,"h",(function(){return T}));var n=i("ce50"),r=i("c84e"),s=i("9b77");function o(e,t=!1){const i=r["e"].SIZE_FIELD_STOPS|r["e"].SIZE_MINMAX_VALUE|r["e"].SIZE_SCALE_STOPS|r["e"].SIZE_UNIT_VALUE,n=(e&(r["f"].FIELD_TARGETS_OUTLINE|r["f"].MINMAX_TARGETS_OUTLINE|r["f"].SCALE_TARGETS_OUTLINE|r["f"].UNIT_TARGETS_OUTLINE))>>>4;return t?i&n:i&~n}const a=0,l=8,c=7,h=8,u=11,d=11,f=12,_=13,p=14,m=15,v=15,g=16,y=17,b=18,w=19,S=20;function x(e,t,i,n,s){switch(e){case r["d"].FILL:return A.from(t,n);case r["d"].LINE:return P.from(t,i);case r["d"].MARKER:return O.from(t);case r["d"].TEXT:return E.from(t);case r["d"].LABEL:return D.from(t,s);default:throw new Error("Unable to createMaterialKey for unknown geometryType "+e)}}function T(e){switch(I.load(e).geometryType){case r["d"].MARKER:return new O(e);case r["d"].FILL:return new A(e);case r["d"].LINE:return new P(e);case r["d"].TEXT:return new E(e);case r["d"].LABEL:return new D(e)}}class I{constructor(e){this._data=0,this._data=e}static load(e){const t=this.shared;return t.data=e,t}set data(e){this._data=e}get data(){return this._data}get geometryType(){return this.bits(h,u)}set geometryType(e){this.setBits(e,h,u)}get mapAligned(){return!!this.bit(S)}set mapAligned(e){this.setBit(S,e)}get sdf(){return!!this.bit(d)}set sdf(e){this.setBit(d,e)}get pattern(){return!!this.bit(f)}set pattern(e){this.setBit(f,e)}get textureBinding(){return this.bits(a,l)}set textureBinding(e){this.setBits(e,a,l)}get geometryTypeString(){switch(this.geometryType){case r["d"].FILL:return"fill";case r["d"].MARKER:return"marker";case r["d"].LINE:return"line";case r["d"].TEXT:return"text";case r["d"].LABEL:return"label";default:throw new n["a"]("Unable to handle unknown geometryType: "+this.geometryType)}}setBit(e,t){const i=1<<e;t?this._data|=i:this._data&=~i}bit(e){return(this._data&1<<e)>>e}setBits(e,t,i){for(let n=t,r=0;n<i;n++,r++)this.setBit(n,0!=(e&1<<r))}bits(e,t){let i=0;for(let n=e,r=0;n<t;n++,r++)i|=this.bit(n)<<r;return i}hasVV(){return!1}setVV(e,t){}getVariation(){return{mapAligned:this.mapAligned,pattern:this.pattern,sdf:this.sdf}}getVariationHash(){return this._data&~(c&this.textureBinding)}}I.shared=new I(0);const M=e=>class extends e{get vvSizeMinMaxValue(){return 0!==this.bit(g)}set vvSizeMinMaxValue(e){this.setBit(g,e)}get vvSizeScaleStops(){return 0!==this.bit(y)}set vvSizeScaleStops(e){this.setBit(y,e)}get vvSizeFieldStops(){return 0!==this.bit(b)}set vvSizeFieldStops(e){this.setBit(b,e)}get vvSizeUnitValue(){return 0!==this.bit(w)}set vvSizeUnitValue(e){this.setBit(w,e)}hasVV(){return super.hasVV()||this.vvSizeMinMaxValue||this.vvSizeScaleStops||this.vvSizeFieldStops||this.vvSizeUnitValue}setVV(e,t){super.setVV(e,t);const i=o(e,t)&e;this.vvSizeMinMaxValue=!!(i&r["e"].SIZE_MINMAX_VALUE),this.vvSizeFieldStops=!!(i&r["e"].SIZE_FIELD_STOPS),this.vvSizeUnitValue=!!(i&r["e"].SIZE_UNIT_VALUE),this.vvSizeScaleStops=!!(i&r["e"].SIZE_SCALE_STOPS)}},C=e=>class extends e{get vvRotation(){return 0!==this.bit(m)}set vvRotation(e){this.setBit(m,e)}hasVV(){return super.hasVV()||this.vvRotation}setVV(e,t){super.setVV(e,t),this.vvRotation=!t&&!!(e&r["e"].ROTATION)}},L=e=>class extends e{get vvColor(){return 0!==this.bit(_)}set vvColor(e){this.setBit(_,e)}hasVV(){return super.hasVV()||this.vvColor}setVV(e,t){super.setVV(e,t),this.vvColor=!t&&!!(e&r["e"].COLOR)}},R=e=>class extends e{get vvOpacity(){return 0!==this.bit(p)}set vvOpacity(e){this.setBit(p,e)}hasVV(){return super.hasVV()||this.vvOpacity}setVV(e,t){super.setVV(e,t),this.vvOpacity=!t&&!!(e&r["e"].OPACITY)}};class A extends(L(R(I))){static load(e){const t=this.shared;return t.data=e,t}static from(e,t){const i=this.load(0);return i.geometryType=r["d"].FILL,t?i.dotDensity=!0:i.setVV(e,!1),i.data}getVariation(){return{...super.getVariation(),dotDensity:this.dotDensity,vvColor:this.vvColor,vvOpacity:this.vvOpacity}}get dotDensity(){return!!this.bit(v)}set dotDensity(e){this.setBit(v,e)}}A.shared=new A(0);class O extends(L(R(C(M(I))))){static load(e){const t=this.shared;return t.data=e,t}static from(e){const t=this.load(0);return t.geometryType=r["d"].MARKER,t.setVV(e,!1),t.data}getVariation(){return{...super.getVariation(),vvColor:this.vvColor,vvRotation:this.vvRotation,vvOpacity:this.vvOpacity,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}O.shared=new O(0);class P extends(L(R(M(I)))){static load(e){const t=this.shared;return t.data=e,t}static from(e,t){const i=this.load(0);return i.geometryType=r["d"].LINE,i.setVV(e,t),i.data}getVariation(){return{...super.getVariation(),vvColor:this.vvColor,vvOpacity:this.vvOpacity,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}P.shared=new P(0);class E extends(L(R(C(M(I))))){static load(e){const t=this.shared;return t.data=e,t}static from(e){const t=this.load(e);return t.geometryType=r["d"].TEXT,t.setVV(e,!1),t.data}getVariation(){return{...super.getVariation(),vvColor:this.vvColor,vvOpacity:this.vvOpacity,vvRotation:this.vvRotation,vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}E.shared=new E(0);class D extends(M(I)){static load(e){const t=this.shared;return t.data=e,t}static from(e,t){const i=this.load(0);return i.geometryType=r["d"].LABEL,i.setVV(e,!1),i.mapAligned=!!Object(s["a"])(t),i.data}getVariation(){return{...super.getVariation(),vvSizeFieldStops:this.vvSizeFieldStops,vvSizeMinMaxValue:this.vvSizeMinMaxValue,vvSizeScaleStops:this.vvSizeScaleStops,vvSizeUnitValue:this.vvSizeUnitValue}}}D.shared=new D(0)},"361b":function(e,t,i){"use strict";i("c120"),i("38a4");var n=i("8e37"),r=(i("1956"),i("d267"),i("9f8b"),i("d45f")),s=i("49f0"),o={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n  mediump vec2 samplePos = mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = u_opacity * color;\n#else\n  gl_FragColor = u_color;\n#endif\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\n#endif\nvoid main() {\n  gl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\n  v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\n#endif\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\n  mediump float dist = length(v_offset);\n  mediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\n  lowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\n  gl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\n  v_color = color * opacity;\n  v_stroke_color = stroke_color * stroke_opacity;\n  v_stroke_width = stroke_width;\n  v_radius = radius;\n  v_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\n  mediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n  v_offset = offset;\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif\n  mediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\n  gl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\n  float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\n  vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\n  return vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\n  mediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\n  mediump vec2 samplePos = mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = v_color[3] * color;\n#else\n  gl_FragColor = v_color;\n#endif\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\n  v_color = color * opacity;\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\n  v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\n#endif\n  vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\n  gl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\n  float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\n  vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\n  return vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n  float d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\n  const float softEdgeRatio = 0.248062016;\n  float size = max(v_size.x, v_size.y);\n  float dist = d * softEdgeRatio * size;\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n  if (v_halo_width > 0.25) {\n    lowp vec4 outlinePixelColor = u_outlineColor;\n    const float outlineLimitRatio = (16.0 / 86.0);\n    float clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\n    outlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\n    gl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_opacity * fillPixelColor;\n  }\n#else\n  lowp vec4 texColor = texture2D(u_texture, v_tex);\n  gl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\n  v_color = color;\n  v_opacity = opacity;\n#ifdef SDF\n  v_halo_width = halo_width;\n#endif\n  float modded = mod(a_opacityInfo, 128.0);\n  float targetOpacity = (a_opacityInfo - modded) / 128.0;\n  float startOpacity = modded / 127.0;\n  float interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\n  v_opacity *= interpolatedOpacity;\n  mediump float a_angle         = a_levelInfo[1];\n  mediump float a_minLevel      = a_levelInfo[2];\n  mediump float a_maxLevel      = a_levelInfo[3];\n  mediump vec2 a_tex            = a_texAngleRange.xy;\n  mediump float delta_z = 0.0;\n  mediump float rotated = mod(a_angle + u_mapRotation, 256.0);\n  delta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\n  delta_z += 1.0 - step(a_minLevel, u_level);\n  delta_z += step(a_maxLevel, u_level);\n  delta_z += step(v_opacity, 0.0);\n  vec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\n  v_size = abs(offset);\n#ifdef SDF\n  offset = (120.0 / 86.0) * offset;\n#endif\n  mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\n  gl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif\n  v_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"varying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#ifdef PATTERN\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform mediump vec2 u_spriteSize;\nuniform sampler2D u_texture;\nconst mediump float tileCoordRatio = 8.0;\n#else\nvarying mediump vec2 v_dasharray;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n  lowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\n  mediump float relativeTexX = mod((v_accumulatedDistance + v_normal.x * v_lineHalfWidth * tileCoordRatio) / u_spriteSize.x, 1.0);\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / u_spriteSize.y);\n  mediump vec2 texCoord = mix(u_pattern_tl, u_pattern_br, vec2(relativeTexX, relativeTexY));\n  lowp vec4 color = texture2D(u_texture, texCoord);\n  gl_FragColor = alpha * v_color[3] * color;\n#else\n  lowp float dashPos =  mod(v_accumulatedDistance, v_dasharray.x + v_dasharray.y);\n  lowp float dashAlpha = clamp(min(dashPos, v_dasharray.x - dashPos) + 0.5, 0.0, 1.0);\n  dashAlpha = max(sign(-v_dasharray.y), dashAlpha);\n  alpha *= dashAlpha;\n  gl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif\n}","line.vert":"attribute vec2 a_pos;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\n#ifndef PATTERN\nuniform mediump vec2 u_dasharray;\nvarying mediump vec2 v_dasharray;\n#endif\nvoid main()\n{\n#pragma main\n  v_color = color * opacity;\n  v_blur = blur + u_antialiasing;\n  v_normal = a_offsetAndNormal.zw * scale;\n  v_lineHalfWidth += (width + u_antialiasing) * 0.5;\n#ifndef PATTERN\n  v_dasharray = u_dasharray * width;\n#endif\n  mediump vec2 dist = v_lineHalfWidth * scale * a_offsetAndNormal.xy;\n  mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) +  u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\n  gl_Position = vec4(pos.xy, u_depth, 1.0);\n  v_accumulatedDistance = a_accumulatedDistance.x;\n  #ifdef ID\n    v_id = u_id / 255.0;\n  #endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\n  lowp float dist = abs(v_normal.y);\n  lowp float alpha = smoothstep(1.0, 0.0, dist);\n  gl_FragColor = alpha * v_color;\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\n  v_color = color * opacity;\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif\n  v_normal = a_xnormal;\n  mediump vec2 dist = u_outline_width * scale * a_offset;\n  mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\n  gl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\n  lowp float dist = texture2D(u_texture, v_tex).a;\n  mediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\n  gl_FragColor = alpha * v_color;\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\n  if (u_halo > 0.5)\n  {\n    v_color = halo_color * opacity;\n    halo_width *= sdfPixel;\n    halo_blur *= sdfPixel;\n  }\n  else\n  {\n    v_color = color * opacity;\n    halo_width = 0.0;\n    halo_blur = 0.0;\n  }\n  float modded = mod(a_opacityInfo, 128.0);\n  float targetOpacity = (a_opacityInfo - modded) / 128.0;\n  float startOpacity = modded / 127.0;\n  float interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\n  v_color *= interpolatedOpacity;\n  mediump float a_angle       = a_levelInfo[1];\n  mediump float a_minLevel    = a_levelInfo[2];\n  mediump float a_maxLevel    = a_levelInfo[3];\n  mediump vec2 a_tex          = a_texAngleRange.xy;\n  mediump float a_visMinAngle    = a_texAngleRange.z;\n  mediump float a_visMaxAngle    = a_texAngleRange.w;\n  mediump float delta_z = 0.0;\n  mediump float angle = mod(a_angle + u_mapRotation, 256.0);\n  if (a_visMinAngle < a_visMaxAngle)\n  {\n    delta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n  }\n  else\n  {\n    delta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n  }\n  delta_z += 1.0 - step(a_minLevel, u_level);\n  delta_z += step(a_maxLevel, u_level);\n  delta_z += step(v_color[3], 0.0);\n  v_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif\n  v_edgeDistance = edgePos - halo_width / size;\n  v_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\n  mediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\n  gl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\nfloat rgba2float(vec4 rgba) {\n  return dot(rgba, rgba2float_factors);\n}"}},a=o;function l(e){let t=a;return e.split("/").forEach(e=>{t&&(t=t[e])}),t}const c=new s["a"](l);function h(e){return c.resolveIncludes(e)}const u=e=>Object(r["b"])({ID:e.id,PATTERN:e.pattern}),d={shaders:e=>({vertexShader:u(e)+h("background/background.vert"),fragmentShader:u(e)+h("background/background.frag")})},f=e=>Object(r["b"])({ID:e.id}),_={shaders:e=>({vertexShader:f(e)+h("circle/circle.vert"),fragmentShader:f(e)+h("circle/circle.frag")})},p=e=>Object(r["b"])({ID:e.id,PATTERN:e.pattern}),m={shaders:e=>({vertexShader:p(e)+h("fill/fill.vert"),fragmentShader:p(e)+h("fill/fill.frag")})},v=e=>Object(r["b"])({ID:e.id}),g={shaders:e=>({vertexShader:v(e)+h("outline/outline.vert"),fragmentShader:v(e)+h("outline/outline.frag")})},y=e=>Object(r["b"])({ID:e.id,SDF:e.sdf}),b={shaders:e=>({vertexShader:y(e)+h("icon/icon.vert"),fragmentShader:y(e)+h("icon/icon.frag")})},w=e=>Object(r["b"])({ID:e.id,PATTERN:e.pattern}),S={shaders:e=>({vertexShader:w(e)+h("line/line.vert"),fragmentShader:w(e)+h("line/line.frag")})},x=e=>Object(r["b"])({ID:e.id}),T={shaders:e=>({vertexShader:x(e)+h("text/text.vert"),fragmentShader:x(e)+h("text/text.frag")})};class I{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach(e=>e.dispose()),this._programByKey.clear()}getMaterialProgram(e,t,i){const r=t.key<<2|this._getMaterialOptionsValue(t.type,i);if(this._programByKey.has(r))return this._programByKey.get(r);const s=this._getProgramTemplate(t.type),{shaders:o}=s,{vertexShader:a,fragmentShader:l}=o(i),c=t.getShaderHeader(),h=t.getShaderMain(),u=a.replace("#pragma header",c).replace("#pragma main",h),d=new n["a"](e,u,l,t.getAttributeLocations());return this._programByKey.set(r,d),d}_getMaterialOptionsValue(e,t){switch(e){case 0:{const e=t;return(e.pattern?1:0)<<1|(e.id?1:0)}case 1:{const e=t;return(e.pattern?1:0)<<1|(e.id?1:0)}case 2:return t.id?1:0;case 3:{const e=t;return(e.pattern?1:0)<<1|(e.id?1:0)}case 4:{const e=t;return(e.sdf?1:0)<<1|(e.id?1:0)}case 5:return t.id?1:0;case 6:return t.id?1:0;default:return 0}}_getProgramTemplate(e){switch(e){case 0:return d;case 5:return _;case 1:return m;case 4:return b;case 3:return S;case 2:return g;case 6:return T;default:return null}}}t["a"]=I},"51b2":function(e,t,i){"use strict";i.d(t,"a",(function(){return a}));var n=i("8c71"),r=i("db21"),s=i("bc05");function o(e,t,i,n,r,s){const{iconRotationAlignment:o,textRotationAlignment:a,iconTranslate:l,iconTranslateAnchor:c,textTranslate:h,textTranslateAnchor:u}=n;let d=0;for(const f of e.colliders){const[e,n]=0===f.partIndex?l:h,_=0===f.partIndex?c:u,p=f.minLod<=s&&s<=f.maxLod;d+=p?0:1,f.enabled=p,f.xScreen=f.xTile*r[0]+f.yTile*r[3]+r[6],f.yScreen=f.xTile*r[1]+f.yTile*r[4]+r[7],0===_?(f.xScreen+=i*e-t*n,f.yScreen+=t*e+i*n):(f.xScreen+=e,f.yScreen+=n),1===(0===f.partIndex?o:a)?(f.dxScreen=f.dxPixels,f.dyScreen=f.dyPixels):(f.dxScreen=i*(f.dxPixels+f.width/2)-t*(f.dyPixels+f.height/2)-f.width/2,f.dyScreen=t*(f.dxPixels+f.width/2)+i*(f.dyPixels+f.height/2)-f.height/2)}e.colliders.length>0&&d===e.colliders.length&&(e.unique.show=!1)}class a{constructor(e,t,i,o,a,l){this._symbols=e,this._styleRepository=o,this._zoom=a,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new s["a"](t,i,r["a"]),this._si=Math.sin(Math.PI*l/180),this._co=Math.cos(Math.PI*l/180);for(const r of e)for(const e of r.symbols)this._allNeededMatrices.has(e.tile)||this._allNeededMatrices.set(e.tile,Object(n["a"])(e.tile.transforms.tileUnitsToPixels))}work(e){const t=this._gridIndex;function i(e){const i=e.xScreen+e.dxScreen,n=e.yScreen+e.dyScreen,r=i+e.width,s=n+e.height,[o,a,l,c]=t.getCellSpan(i,n,r,s);for(let h=a;h<=c;h++)for(let e=o;e<=l;e++){const o=t.cells[h][e];for(const e of o){const t=e.xScreen+e.dxScreen,o=e.yScreen+e.dyScreen,a=t+e.width,l=o+e.height;if(!(r<t||i>a||s<o||n>l))return!0}}return!1}const n=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const t=this._symbols[this._currentLayerCursor],r=this._getProperties(t.styleLayerUID);for(;this._currentSymbolCursor<t.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-n>e)return!1;const s=t.symbols[this._currentSymbolCursor];if(!s.unique.show)continue;o(s,this._si,this._co,r,this._allNeededMatrices.get(s.tile),this._zoom);const a=s.unique;if(!a.show)continue;const{iconAllowOverlap:l,iconIgnorePlacement:c,textAllowOverlap:h,textIgnorePlacement:u}=r;for(const e of s.colliders){if(!e.enabled)continue;const t=a.parts[e.partIndex];t.show&&(!(e.partIndex?h:l)&&i(e)&&(e.hard?a.show=!1:t.show=!1))}if(a.show)for(const e of s.colliders){if(!e.enabled)continue;if(e.partIndex?u:c)continue;if(!a.parts[e.partIndex].show)continue;const t=e.xScreen+e.dxScreen,i=e.yScreen+e.dyScreen,n=t+e.width,r=i+e.height,[s,o,l,h]=this._gridIndex.getCellSpan(t,i,n,r);for(let a=o;a<=h;a++)for(let t=s;t<=l;t++)this._gridIndex.cells[a][t].push(e)}}}return!0}_getProperties(e){const t=this._styleProps.get(e);if(t)return t;const i=this._zoom,n=this._styleRepository.getStyleLayerByUID(e),r=0!==n.getLayoutValue("symbol-placement",i);let s=n.getLayoutValue("icon-rotation-alignment",i);2===s&&(s=r?0:1);let o=n.getLayoutValue("text-rotation-alignment",i);2===o&&(o=r?0:1);const a=n.getPaintValue("icon-translate",i),l=n.getPaintValue("icon-translate-anchor",i),c=n.getPaintValue("text-translate",i),h=n.getPaintValue("text-translate-anchor",i),u={iconAllowOverlap:n.getLayoutValue("icon-allow-overlap",i),iconIgnorePlacement:n.getLayoutValue("icon-ignore-placement",i),textAllowOverlap:n.getLayoutValue("text-allow-overlap",i),textIgnorePlacement:n.getLayoutValue("text-ignore-placement",i),iconRotationAlignment:s,textRotationAlignment:o,iconTranslateAnchor:l,iconTranslate:a,textTranslateAnchor:h,textTranslate:c};return this._styleProps.set(e,u),u}}},"81af":function(e,t,i){"use strict";i.d(t,"a",(function(){return M}));var n=i("c120"),r=i("f4cc"),s=i("2eab"),o=i("d7f2"),a=i("dfa0"),l=i("ae54"),c=i("2582"),h=(i("9f8b"),i("1956"),i("a1ff")),u=(i("d267"),i("a9c0"));class d{constructor(e,t){this._width=0,this._height=0,this._free=[],this._width=e,this._height=t,this._free.push(new u["a"](0,0,e,t))}get width(){return this._width}get height(){return this._height}allocate(e,t){if(e>this._width||t>this._height)return new u["a"];let i=null,n=-1;for(let r=0;r<this._free.length;++r){const s=this._free[r];e<=s.width&&t<=s.height&&(null===i||s.y<=i.y&&s.x<=i.x)&&(i=s,n=r)}return null===i?new u["a"]:(this._free.splice(n,1),i.width<i.height?(i.width>e&&this._free.push(new u["a"](i.x+e,i.y,i.width-e,t)),i.height>t&&this._free.push(new u["a"](i.x,i.y+t,i.width,i.height-t))):(i.width>e&&this._free.push(new u["a"](i.x+e,i.y,i.width-e,i.height)),i.height>t&&this._free.push(new u["a"](i.x,i.y+t,e,i.height-t))),new u["a"](i.x,i.y,e,t))}release(e){for(let t=0;t<this._free.length;++t){const i=this._free[t];if(i.y===e.y&&i.height===e.height&&i.x+i.width===e.x)i.width+=e.width;else if(i.x===e.x&&i.width===e.width&&i.y+i.height===e.y)i.height+=e.height;else if(e.y===i.y&&e.height===i.height&&e.x+e.width===i.x)i.x=e.x,i.width+=e.width;else{if(e.x!==i.x||e.width!==i.width||e.y+e.height!==i.y)continue;i.y=e.y,i.height+=e.height}this._free.splice(t,1),this.release(e)}this._free.push(e)}}var f=d;class _{constructor(e,t,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=t,this._glyphSource=i,this._binPack=new f(e-4,t-4),this._glyphData.push(new Uint8Array(e*t)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,t){const i=[],n=this._glyphSource,r=new Set,s=1/256;for(const a of t){const e=Math.floor(a*s);r.add(e)}const o=[];return r.forEach(t=>{if(t<=256){const i=e+t;if(this._rangePromises.has(i))o.push(this._rangePromises.get(i));else{const r=n.getRange(e,t).then(()=>{this._rangePromises.delete(i)},()=>{this._rangePromises.delete(i)});this._rangePromises.set(i,r),o.push(r)}}}),Promise.all(o).then(()=>{let r=this._glyphIndex[e];r||(r={},this._glyphIndex[e]=r);for(const s of t){const t=r[s];if(t){i[s]={sdf:!0,rect:t.rect,metrics:t.metrics,page:t.page,code:s};continue}const o=n.getGlyph(e,s);if(!o||!o.metrics)continue;const a=o.metrics;let l;if(0===a.width)l=new u["a"](0,0,0,0);else{const e=3,t=a.width+2*e,i=a.height+2*e;let n=t%4?4-t%4:4,r=i%4?4-i%4:4;1===n&&(n=5),1===r&&(r=5),l=this._binPack.allocate(t+n,i+r),l.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new f(this.width-4,this.height-4),l=this._binPack.allocate(t+n,i+r));const s=this._glyphData[this._currentPage],c=o.bitmap;let h,u;if(c)for(let o=0;o<i;o++){h=t*o,u=this.width*(l.y+o+1)+l.x;for(let e=0;e<t;e++)s[u+e+1]=c[h+e]}}r[s]={rect:l,metrics:a,tileIDs:null,page:this._currentPage},i[s]={sdf:!0,rect:l,metrics:a,page:this._currentPage,code:s},this._dirties[this._currentPage]=!0}return i})}removeGlyphs(e){for(const t in this._glyphIndex){const i=this._glyphIndex[t];if(!i)continue;let n;for(const t in i)if(n=i[t],n.tileIDs.delete(e),0===n.tileIDs.size){const e=this._glyphData[n.page],r=n.rect;let s,o;for(let t=0;t<r.height;t++)for(s=this.width*(r.y+t)+r.x,o=0;o<r.width;o++)e[s+o]=0;delete i[t],this._dirties[n.page]=!0}}}bind(e,t,i,n=0){this._textures[i]||(this._textures[i]=new h["a"](e,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const r=this._textures[i];r.setSamplingMode(t),this._dirties[i]&&r.setData(this._glyphData[i]),e.bindTexture(r,n),this._dirties[i]=!1}dispose(){this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}}var p=_,m=i("013b");class v{constructor(e){if(this._metrics=[],this._bitmaps=[],e)for(;e.next();)switch(e.tag()){case 1:{const t=e.getMessage();for(;t.next();)switch(t.tag()){case 3:{const e=t.getMessage();let i,n,r,s,o,a,l;for(;e.next();)switch(e.tag()){case 1:i=e.getUInt32();break;case 2:n=e.getBytes();break;case 3:r=e.getUInt32();break;case 4:s=e.getUInt32();break;case 5:o=e.getSInt32();break;case 6:a=e.getSInt32();break;case 7:l=e.getUInt32();break;default:e.skip()}e.release(),i&&(this._metrics[i]={width:r,height:s,left:o,top:a,advance:l},this._bitmaps[i]=n);break}default:t.skip()}t.release();break}default:e.skip()}}getMetrics(e){return this._metrics[e]}getBitmap(e){return this._bitmaps[e]}}class g{constructor(){this._ranges=[]}getRange(e){return this._ranges[e]}addRange(e,t){this._ranges[e]=t}}class y{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,t){const i=this._getFontStack(e);if(i.getRange(t))return Promise.resolve();const n=256*t,r=n+255,o=this._baseURL.replace("{fontstack}",e).replace("{range}",n+"-"+r);return Object(s["default"])(o,{responseType:"array-buffer"}).then(e=>{i.addRange(t,new v(new m["a"](new Uint8Array(e.data),new DataView(e.data))))}).catch(()=>{i.addRange(t,new v)})}getGlyph(e,t){const i=this._getFontStack(e);if(!i)return;const n=Math.floor(t/256);if(n>256)return;const r=i.getRange(n);return r?{metrics:r.getMetrics(t),bitmap:r.getBitmap(t)}:void 0}_getFontStack(e){let t=this._glyphInfo[e];return t||(t=this._glyphInfo[e]=new g),t}}var b=y;class w{constructor(e,t,i=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(e<=0||t<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,i>0&&(this._maxItemSize=i),this._binPack=new f(e-4,t-4)}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new f(this._pageWidth-4,this._pageHeight-4);const e=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),i=new Uint32Array(e*t);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,t=!1){let i=this._mosaicRects[e];if(i)return i;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;const n=this._sprites.getSpriteInfo(e);if(!n||!n.width||!n.height||n.width<0||n.height<0)return null;const r=n.width,s=n.height,[o,a,l]=this._allocateImage(r,s);return o.width<=0?null:(this._copy(o,n,a,l,t),i={rect:o,width:r,height:s,sdf:n.sdf,simplePattern:!1,pixelRatio:n.pixelRatio,page:a},this._mosaicRects[e]=i,i)}getSpriteItems(e){const t={};for(const i of e)t[i]=this.getSpriteItem(i);return t}getMosaicItemPosition(e,t){const i=this.getSpriteItem(e,t),n=i&&i.rect;if(!n)return null;n.width=i.width,n.height=i.height;const r=i.width,s=i.height,o=2,a=this._size[i.page];return{size:[i.width,i.height],tl:[(n.x+o)/a[0],(n.y+o)/a[1]],br:[(n.x+o+r)/a[0],(n.y+o+s)/a[1]],page:i.page}}bind(e,t,i=0,n=0){this._textures[i]||(this._textures[i]=new h["a"](e,{pixelFormat:6408,dataType:5121,wrapMode:33071,width:this._size[i][0],height:this._size[i][1]},new Uint8Array(this._mosaicsData[i].buffer)));const r=this._textures[i];r.setSamplingMode(t),this._dirties[i]&&r.setData(new Uint8Array(this._mosaicsData[i].buffer)),e.bindTexture(r,n),this._dirties[i]=!1}static _copyBits(e,t,i,n,r,s,o,a,l,c,h){let u=n*t+i,d=a*s+o;if(h){d-=s;for(let o=-1;o<=c;o++,u=((o+c)%c+n)*t+i,d+=s)for(let t=-1;t<=l;t++)r[d+t]=e[u+(t+l)%l]}else for(let f=0;f<c;f++){for(let t=0;t<l;t++)r[d+t]=e[u+t];u+=t,d+=s}}_copy(e,t,i,n,r,s){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const o=new Uint32Array(s?s.buffer:this._sprites.image.buffer),a=this._mosaicsData[i];a&&o||console.error("Source or target images are uninitialized!");const l=2,c=s?t.width:this._sprites.width;w._copyBits(o,c,t.x,t.y,a,n[0],e.x+l,e.y+l,t.width,t.height,r),this._dirties[i]=!0}_allocateImage(e,t){e+=2,t+=2;const i=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<i){const i=new u["a"](0,0,e,t);return this._mosaicsData.push(new Uint32Array(e*t)),this._dirties.push(!0),this._size.push([e,t]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[e,t]]}let n=e%4?4-e%4:4,r=t%4?4-t%4:4;1===n&&(n=5),1===r&&(r=5);const s=this._binPack.allocate(e+n,t+r);return s.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new f(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[s,this._currentPage,[this._pageWidth,this._pageHeight]]}dispose(){this._binPack=null,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}}var S=w,x=i("bf7f");const T=new o["a"](10),I=new Map;class M{constructor(e,t,i){this._vectorTileLayer=e,this._styleRepository=t,this.devicePixelRatio=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._vectorTileLayer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(e){const t=this._vectorTileLayer,i=t.sourceNameToSource,r=[];for(const n in i)r.push(this._fetchTileMap(i[n],e));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,e),this._spriteSourcePromise.then(e=>{this._spriteMosaic=new S(1024,1024,250),this._spriteMosaic.setSpriteSource(e)});const s=this._styleRepository,o=new b(s.glyphs);return this._glyphMosaic=new p(1024,1024,o),this._broadcastPromise=Object(a["b"])("WorkerTileHandler",{client:this,scheduler:e.scheduler,signal:e.signal}).then(i=>(this._connection=i,Promise.all(this._connection.broadcast("setStyle",{style:t.currentStyleInfo.style,vectorTileLayerMaxBuffers:Object(n["a"])("vectortilelayer-max-buffers")},e)))),Promise.all(r)}async updateStyle(e){return await this._broadcastPromise,this._broadcastPromise=new Promise((t,i)=>{Promise.all(this._connection.broadcast("updateStyle",e)).then(t,i)}),this._broadcastPromise}async setStyle(e,t){await this._broadcastPromise,this._styleRepository=e;const i=this._vectorTileLayer.sourceNameToSource,r=[];for(const n in i)r.push(this._fetchTileMap(i[n],null));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then(e=>{this._spriteMosaic=new S(1024,1024,250),this._spriteMosaic.setSpriteSource(e)});const s=new b(e.glyphs);return this._glyphMosaic=new p(1024,1024,s),this._broadcastPromise=new Promise((e,i)=>{Promise.all(this._connection.broadcast("setStyle",{style:t,vectorTileLayerMaxBuffers:Object(n["a"])("vectortilelayer-max-buffers")})).then(e,i)}),r.push(this._broadcastPromise),Promise.all(r)}fetchTileData(e,t){return this._getRefKeys(e,t).then(e=>{const i=this._vectorTileLayer.sourceNameToSource,n=[];for(const t in i)n.push(t);return this._getSourcesData(n,e,t)})}parseTileData(e,t){const i=e&&e.data;if(!i)return Promise.resolve(null);const{sourceName2DataAndRefKey:n,transferList:r}=i;return 0===Object.keys(n).length?Promise.resolve(null):this._broadcastPromise.then(()=>this._connection.getAvailableClient().then(i=>i.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:n,styleLayerUIDs:e.styleLayerUIDs},{...t,transferList:r}).then(e=>({tileData:e}))))}async getSprites(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}perfReport({key:e,milliseconds:t}){Object(x["c"])(e,t,"ms")}async _getTilePayload(e,t,i){const n=l["a"].pool.acquire(e.id),s=this._vectorTileLayer.sourceNameToSource[t].getSourceTileUrl(n.level,n.row,n.col);l["a"].pool.release(n);try{return{protobuff:await this.request(s,i),sourceName:t}}catch(o){if(Object(r["n"])(o))throw o;return{protobuff:null,sourceName:t}}}request(e,t){return Object(s["default"])(e,{responseType:"array-buffer",...t}).then(({data:e})=>e)}async _fetchTileMap(e,t){if(e.capabilities.operations.supportsTileMap&&e.tileIndex)return Promise.resolve();if(!e.tileMapURL)return;const i=T.get(e.tileMapURL);if(i)return void(e.tileIndex=i);let n;if(I.has(e.tileMapURL)){try{n=await I.get(e.tileMapURL),e.tileIndex=new c["a"](n.data)}catch(a){if(Object(r["n"])(a))throw a}return}const o=Object(s["default"])(e.tileMapURL,t);I.set(e.tileMapURL,o);try{n=await o,I.delete(e.tileMapURL),T.put(e.tileMapURL,e.tileIndex),e.tileIndex=new c["a"](n.data)}catch(a){if(I.delete(e.tileMapURL),Object(r["n"])(a))throw a}}_getRefKeys(e,t){const i=this._vectorTileLayer.sourceNameToSource,n=new Array;for(const r in i){const s=i[r].getRefKey(e,t);n.push(s)}return Object(r["k"])(n)}_getSourcesData(e,t,i){const n=[];for(let r=0;r<t.length;r++)if(null==t[r].value||null==e[r])n.push(null);else{const s=this._getTilePayload(t[r].value,e[r],i);n.push(s)}return Object(r["k"])(n).then(e=>{const i={},n=[];for(let r=0;r<e.length;r++)if(e[r].value&&e[r].value&&e[r].value.protobuff&&e[r].value.protobuff.byteLength>0){const s=t[r].value.id;i[e[r].value.sourceName]={refKey:s,protobuff:e[r].value.protobuff},n.push(e[r].value.protobuff)}return{sourceName2DataAndRefKey:i,transferList:n}})}}},"9b77":function(e,t,i){"use strict";function n(e){switch(e){case"above-along":case"below-along":case"center-along":return 1;default:return 0}}i.d(t,"a",(function(){return n}))},a9a2:function(e,t,i){"use strict";i.d(t,"a",(function(){return o})),i.d(t,"b",(function(){return s})),i.d(t,"c",(function(){return a})),i.d(t,"d",(function(){return l}));var n=i("d114");function r(e,t){return Array.isArray(t)?(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3]):(e[0]=t.r,e[1]=t.g,e[2]=t.b,e[3]=t.a),e}function s(e,t=0,i=!1){const n=e[t+3];return e[t+0]*=n,e[t+1]*=n,e[t+2]*=n,i||(e[t+3]*=255),e}function o(e){return s(r([],e))}function a(e){if(!e)return 0;const{r:t,g:i,b:r,a:s}=e;return Object(n["b"])(t*s,i*s,r*s,255*s)}function l(e){if(!e)return 0;const[t,i,r,s]=e;return Object(n["b"])(t*(s/255),i*(s/255),r*(s/255),s)}},a9c0:function(e,t,i){"use strict";class n{constructor(e=0,t=0,i=0,n=0){this.x=e,this.y=t,this.width=i,this.height=n}get isEmpty(){return this.width<=0||this.height<=0}union(e){this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.width=Math.max(this.width,e.width),this.height=Math.max(this.height,e.height)}}t["a"]=n},ac41:function(e,t,i){"use strict";i.d(t,"a",(function(){return o}));var n=i("b2b2"),r=i("db21");function s(e,t){if(e.priority-t.priority)return e.priority-t.priority;const i=e.tile.key,n=t.tile.key;return i.world-n.world?i.world-n.world:i.level-n.level?i.level-n.level:i.row-n.row?i.row-n.row:i.col-n.col?i.col-n.col:e.xTile-t.xTile?e.xTile-t.xTile:e.yTile-t.yTile}class o{constructor(e,t,i,n,r,s){this._visibleTiles=e,this._symbolRepository=t,this._createCollisionJob=i,this._assignTileSymbolsOpacity=n,this._symbolLayerSorter=r,this._isLayerVisible=s,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}get running(){return this._running}setScreenSize(e,t){this._screenWidth===e&&this._screenHeight===t||this.restart(),this._screenWidth=e,this._screenHeight=t}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(e){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const t=performance.now();if(!this._selectionJob.work(e))return!1;if(this._selectionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const t=performance.now();if(!this._collisionJob.work(e))return!1;if(this._collisionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const t=performance.now();if(!this._opacityJob.work(e))return!1;if(this._opacityJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}return this._running=!1,!0}_createSelectionJob(){const e=this._symbolRepository.uniqueSymbols,t=[];let i=0,n=0;const r=this._isLayerVisible;function o(o){let a;const l=performance.now();for(;n<e.length;n++,i=0){const s=e[n],c=s.styleLayerUID;if(!r(c)){t[n]||(t[n]={styleLayerUID:c,symbols:[]});continue}t[n]=t[n]||{styleLayerUID:c,symbols:[]};const h=t[n];for(;i<s.uniqueSymbols.length;i++){if(a=s.uniqueSymbols[i],i%100==99&&performance.now()-l>o)return!1;let e=null,t=!1,n=!1;for(const i of a.tileSymbols)if(i.selectedForRendering=!1,!n||!t){const r=i.tile;(!e||r.isCoverage||r.neededForCoverage&&!t)&&(e=i,(r.neededForCoverage||r.isCoverage)&&(n=!0),r.isCoverage&&(t=!0))}if(e.selectedForRendering=!0,n){h.symbols.push(e),a.show=!0;for(const e of a.parts)e.show=!0}else a.show=!1}}for(const e of t)e.symbols.sort(s);return!0}const a=this._symbolLayerSorter;return{work:o,get sortedSymbols(){return t.sort(a)}}}_createOpacityJob(){const e=this._assignTileSymbolsOpacity,t=this._visibleTiles;let i=0;function r(t,i){const n=t.symbols;for(const[e,r]of n)a(r,i);e(t,i);for(const e of t.childrenTiles)r(e,i)}return{work(e){const s=performance.now();for(;i<t.length;i++){if(performance.now()-s>e)return!1;const o=t[i];Object(n["k"])(o.parentTile)||r(o,performance.now())}return!0}}}}function a(e,t){for(const i of e){const e=i.unique;for(const i of e.parts){const n=i.targetOpacity>.5?1:-1;i.startOpacity+=n*((t-i.startTime)/r["d"]),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=t,i.targetOpacity=e.show&&i.show?1:0}}}},bf7f:function(e,t,i){"use strict";function n(e,t,i,n,r,s){e.fillStyle=t,e.fillRect(i,n,r,s)}function r(e,t,i,n,r,s){e.strokeStyle=t,e.strokeRect(i,n,r,s)}function s(e,t){e.strokeStyle="black";const i=t.cellSize,n=t.rows,r=t.columns;for(let s=0;s<n;s++){const n=t.cells[s],o=s*i,a=(s+1)*i;for(let t=0;t<r;t++){const r=n[t],s=t*i,l=(t+1)*i;e.strokeRect(s,o,l-s,a-o),e.fillText("cells:"+r.length,s+4,o+12)}}}function o(e,t){const i=window.COLLISION_XRAY;for(let s=0;s<t.length;++s){const o=!t[s].unique.show;if(i||!o)for(const a of t[s].colliders){if(!a.enabled)continue;const l=!t[s].unique.parts[a.partIndex].show;if(!i&&l)continue;const c=a.xScreen,h=a.yScreen,u=a.dxScreen,d=a.dyScreen;e.globalAlpha=o||l?.2:1,n(e,"green",c-1,h-1,3,3),r(e,"red",c+u,h+d,a.width,a.height),n(e,"blue",c+u-1,h+d-1,3,3),e.globalAlpha=1}}}function a(e,t,i){if(!window.PERFORMANCE_RECORDING_STORAGE)return;const n=window.PERFORMANCE_RECORDING_STORAGE;n.perf=n.perf||{};const r=n.perf;r[e]=r[e]||{start:null,time:0,min:void 0,max:void 0,samples:[],unit:i},r[e].time+=t,r[e].samples.push(t),(null==r[e].min||t<r[e].min)&&(r[e].min=t),(null==r[e].max||t>r[e].max)&&(r[e].max=t)}i.d(t,"a",(function(){return o})),i.d(t,"b",(function(){return s})),i.d(t,"c",(function(){return a}))},c84e:function(e,t,i){"use strict";var n,r,s,o,a,l,c;i.d(t,"a",(function(){return c})),i.d(t,"b",(function(){return o})),i.d(t,"c",(function(){return s})),i.d(t,"d",(function(){return n})),i.d(t,"e",(function(){return a})),i.d(t,"f",(function(){return l})),function(e){e[e.FILL=0]="FILL",e[e.LINE=1]="LINE",e[e.MARKER=2]="MARKER",e[e.TEXT=3]="TEXT",e[e.LABEL=4]="LABEL"}(n||(n={})),function(e){e[e.SUCCEEDED=0]="SUCCEEDED",e[e.FAILED_OUT_OF_MEMORY=1]="FAILED_OUT_OF_MEMORY"}(r||(r={})),function(e){e[e.NONE=0]="NONE",e[e.MAP=1]="MAP",e[e.LABEL=2]="LABEL",e[e.LABEL_ALPHA=4]="LABEL_ALPHA",e[e.HITTEST=8]="HITTEST",e[e.HIGHLIGHT=16]="HIGHLIGHT",e[e.CLIP=32]="CLIP",e[e.DEBUG=64]="DEBUG",e[e.NUM_DRAW_PHASES=9]="NUM_DRAW_PHASES"}(s||(s={})),function(e){e[e.SIZE=0]="SIZE",e[e.COLOR=1]="COLOR",e[e.OPACITY=2]="OPACITY",e[e.ROTATION=3]="ROTATION"}(o||(o={})),function(e){e[e.NONE=0]="NONE",e[e.OPACITY=1]="OPACITY",e[e.COLOR=2]="COLOR",e[e.ROTATION=4]="ROTATION",e[e.SIZE_MINMAX_VALUE=8]="SIZE_MINMAX_VALUE",e[e.SIZE_SCALE_STOPS=16]="SIZE_SCALE_STOPS",e[e.SIZE_FIELD_STOPS=32]="SIZE_FIELD_STOPS",e[e.SIZE_UNIT_VALUE=64]="SIZE_UNIT_VALUE"}(a||(a={})),function(e){e[e.MINMAX_TARGETS_OUTLINE=128]="MINMAX_TARGETS_OUTLINE",e[e.SCALE_TARGETS_OUTLINE=256]="SCALE_TARGETS_OUTLINE",e[e.FIELD_TARGETS_OUTLINE=512]="FIELD_TARGETS_OUTLINE",e[e.UNIT_TARGETS_OUTLINE=1024]="UNIT_TARGETS_OUTLINE"}(l||(l={})),function(e){e[e.SPRITE=0]="SPRITE",e[e.GLYPH=1]="GLYPH"}(c||(c={}))},c8dd:function(e,t,i){"use strict";i.d(t,"a",(function(){return F})),i.d(t,"b",(function(){return O})),i.d(t,"c",(function(){return P})),i.d(t,"d",(function(){return U})),i.d(t,"e",(function(){return N})),i.d(t,"f",(function(){return K})),i.d(t,"g",(function(){return X})),i.d(t,"h",(function(){return z})),i.d(t,"i",(function(){return V})),i.d(t,"j",(function(){return H})),i.d(t,"k",(function(){return j})),i.d(t,"l",(function(){return x})),i.d(t,"m",(function(){return k})),i.d(t,"n",(function(){return E})),i.d(t,"o",(function(){return D})),i.d(t,"p",(function(){return A}));i("c120");var n=i("e92d"),r=i("ce50"),s=(i("38a4"),i("a915"),i("9f8b"),i("1956"),i("a1ff"),i("d267"),i("c84e")),o=(i("a9a2"),i("ecd7"));class a{constructor(){this.color=[0,0,0,0],this.haloColor=[0,0,0,0],this.haloSize=0,this.size=12,this.angle=0,this.offsetX=0,this.offsetY=0,this.hAnchor=0,this.vAnchor=0}acquire(e,t,i,n,r,s,o,a,l){this.color=e,this.haloColor=t,this.haloSize=i,this.size=n,this.angle=r,this.offsetX=s,this.offsetY=o,this.hAnchor=a,this.vAnchor=l}release(){this.color[0]=this.color[1]=this.color[2]=this.color[3]=0,this.haloColor[0]=this.haloColor[1]=this.haloColor[2]=this.haloColor[3]=0,this.haloSize=0,this.size=0,this.angle=0,this.offsetX=0,this.offsetY=0,this.hAnchor=0,this.vAnchor=0}}a.pool=new o["a"](a);const l=n["a"].getLogger("esri.views.2d.engine.webgl.Utils"),c="geometry",h=[{name:c,strideInBytes:32,divisor:0}],u=[{name:c,strideInBytes:32,divisor:0}],d=[{name:c,strideInBytes:12,divisor:0}],f=[{name:c,strideInBytes:36,divisor:0}],_=[{name:c,strideInBytes:32,divisor:0}],p=[{name:c,strideInBytes:36,divisor:0}];function m(e){const t={};for(const i of e)t[i.name]=i.strideInBytes;return t}const v=m(h),g=m(u),y=m(d),b=m(f),w=m(_),S=m(p);function x(e,t){switch(e){case s["d"].MARKER:return v;case s["d"].FILL:return t?y:g;case s["d"].LINE:return b;case s["d"].TEXT:return w;case s["d"].LABEL:return S}}const T=[c],I=[c],M=[c],C=[c],L=[c];function R(e){switch(e){case s["d"].MARKER:return T;case s["d"].FILL:return I;case s["d"].LINE:return M;case s["d"].TEXT:return C;case s["d"].LABEL:return L}}function A(e){switch(e%4){case 0:case 2:return 4;case 1:case 3:return 1}}function O(e,t){switch(t%4){case 0:case 2:return new Uint32Array(Math.floor(e*t/4));case 1:case 3:return new Uint8Array(e*t)}}function P(e,t){switch(t%4){case 0:case 2:return new Uint32Array(e);case 1:case 3:return new Uint8Array(e)}}function E(e){return null!=e}function D(e){return"number"==typeof e}function z(e,t){switch(e){case"butt":return 0;case"round":return t?2:1;case"square":return 2;default:return l.error(new r["a"]("mapview-invalid-type",`Cap type ${e} is not a valid option. Defaulting to round`)),1}}function V(e){switch(e){case"miter":return 2;case"bevel":return 0;case"round":return 1;default:return l.error(new r["a"]("mapview-invalid-type",`Join type ${e} is not a valid option. Defaulting to round`)),1}}function k(e){switch(e){case"opacity":return s["b"].OPACITY;case"color":return s["b"].COLOR;case"rotation":return s["b"].ROTATION;case"size":return s["b"].SIZE;default:return l.error("Cannot interpret unknown vv: "+e),null}}function U(e,t,i,n,r,s,o){for(const l in s){const t=s[l].stride,n=A(t),o=s[l].data,a=i[l].data,c=t*r.vertexCount/n,h=t*e/n,u=t*r.vertexFrom/n;for(let e=0;e<c;++e)a[e+h]=o[e+u]}const a=r.indexCount;for(let l=0;l<a;++l)n[l+t]=o[l+r.indexFrom]-r.vertexFrom+e}const F={[c]:35044};function N(e,t){const i=[];for(let n=0;n<5;++n){const r=R(n),s={};for(const e of r)s[e]={data:t(n,e)};i.push({data:e(n),buffers:s})}return i}function B(e){switch(e){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5126:case 5124:case 5125:return 4}}function j(e){switch(e){case 5121:return 1;case 32819:return 2;case 5126:return 4;default:return void l.error(new r["a"]("webgl-utils","Unable to handle type "+e))}}function H(e){switch(e){case 5121:return Uint8Array;case 32819:return Uint16Array;case 5126:return Float32Array;default:return void l.error(new r["a"]("webgl-utils","Unable to handle type "+e))}}function q(e){const t={};for(const i in e){const n=e[i];let r=0;t[i]=n.map(e=>{const t={...e,normalized:e.normalized||!1,divisor:e.divisor||0,offset:r,stride:0};return r+=e.count*B(e.type),t}),t[i].forEach(e=>e.stride=r)}return t}const W=e=>{const t={};for(const i in e)for(const n of e[i])t[n.name]=n.location;return t},J=e=>{const t={};for(const i in e){const n=e[i];t[i]=n.length?n[0].stride:0}return t},G=new Map,K=(e,t)=>{if(!G.has(e)){const i=q(t),n={strides:J(i),bufferLayouts:i,attributes:W(t)};G.set(e,n)}return G.get(e)};function X(e){e(s["d"].MARKER),e(s["d"].FILL),e(s["d"].LINE),e(s["d"].TEXT),e(s["d"].LABEL)}},ce88:function(e,t,i){"use strict";i.r(t);var n=i("a4ee"),r=(i("c120"),i("b2b2")),s=(i("e92d"),i("cea0"),i("59b2")),o=i("d386"),a=(i("e041"),i("8eed"),i("f402"),i("f4cc")),l=i("3795"),c=i("1cb4"),h=i("901e"),u=i("8b9d"),d=i("66af"),f=i("45e3"),_=i("365a"),p=i("9180"),m=i("aefa"),v=i("ae54"),g=i("8c71"),y=i("66b9"),b=i("81af"),w=i("cba1"),S=i("bc05"),x=i("51b2"),T=i("ac41"),I=i("d5e4");function M(e,t){const i=[],n=new I["a"](4096,i,()=>{const e=new w["b"];return e.show=!1,e.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),e.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),e}),r=new T["a"](i,n,(t,i,n)=>new x["a"](t,i,n,e.styleRepository,e.key.level,0),(e,t)=>{Object(S["d"])(e,t,!1)},()=>0,e=>{const i=t.getStyleLayerByUID(e).getLayoutProperty("visibility");return!i||1!==i.getValue()});i.push(e),n.add(e),r.setScreenSize(512,512),r.continue(1/0)}class C extends b["a"]{constructor(e,t,i,n,r){super(e,t,i),this._memCache=n,this._loader=r,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map}destroy(){this._ongoingRequestToController.forEach(e=>e.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(e,t,i,n){const s=new v["a"](e,t,i,0);let o=this._memCache.get(s.id);if(Object(r["k"])(o))return o.retain(),o;const l=await this._getVectorTileData(s);if(Object(a["w"])(n),!this._vectorTileLayer)return null;if(o=this._memCache.get(s.id),Object(r["k"])(o))return o.retain(),o;const c=this._vectorTileLayer.tileInfo.getTileBounds(Object(p["l"])(),s);return o=new y["a"](s,this._styleRepository,c,[512,512],this._memCache),Object(r["k"])(l)&&l.tileData?(o.setData(l.tileData),o.retain(),this._memCache.put(s.id,o,o.getMemoryUsage()*o.referenced,m["a"])):o.setData(null),o.neededForCoverage=!0,o.transforms.tileUnitsToPixels=Object(g["c"])(1/8,0,0,0,1/8,0,0,0,1),M(o,this._styleRepository),o}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,n={signal:i.signal},r=this._getParsedVectorTileData(e,n).then(e=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),e)).catch(()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null));return this._ongoingTileRequests.set(t,r),this._ongoingRequestToController.set(t,i),r}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then(i=>this.parseTileData({key:e,data:i},t))}request(e,t){return this._loader.request(e,"binary",t)}}var L=C,R=i("3b1a"),A=i("361b");const O=1e-6;class P{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache=new Map,this._vtlMaterialManager=new A["a"]}dispose(){this._brushCache&&(this._brushCache.forEach(e=>e.dispose()),this._brushCache=null),this._vtlMaterialManager=Object(r["f"])(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(e,t,i){const{context:n}=e,r=i.layers;i.backgroundBucketIds.length>0&&(e.renderPass="background",i.backgroundBucketIds.forEach(n=>this._renderStyleLayer(i.getLayerById(n),e,t,!0))),n.setBlendingEnabled(!1),n.setDepthTestEnabled(!0),n.setDepthWriteEnabled(!0),n.setDepthFunction(515),e.renderPass="opaque";for(let s=r.length-1;s>=0;s--)this._renderStyleLayer(r[s],e,t,!1);n.setDepthWriteEnabled(!1),n.setBlendingEnabled(!0),n.setBlendFunctionSeparate(1,771,1,771),e.renderPass="translucent";for(let s=0;s<r.length;s++)this._renderStyleLayer(r[s],e,t,!1);n.setDepthTestEnabled(!1),e.renderPass="symbol";for(let s=0;s<r.length;s++)this._renderStyleLayer(r[s],e,t,!1);n.bindVAO()}_renderStyleLayer(e,t,i,n=!1){if(!(n||e&&i.layerData.has(e.uid)))return;const r=e.getLayoutProperty("visibility");if(r&&1===r.getValue())return;const{renderPass:s}=t;let o;switch(e.type){case 0:if("background"!==s)return;o="vtlBackground";break;case 1:if("opaque"!==s&&"translucent"!==t.renderPass)return;o="vtlFill";break;case 2:if("translucent"!==s)return;o="vtlLine";break;case 4:if("symbol"!==s)return;o="vtlCircle";break;case 3:if("symbol"!==s)return;o="vtlSymbol"}const a=t.displayLevel;void 0!==e.minzoom&&e.minzoom>a+O||void 0!==e.maxzoom&&e.maxzoom<=a-O||(t.styleLayerUID=e.uid,t.styleLayer=e,this.drawWithBrush(t,i,o))}drawWithBrush(e,t,i){if(!this._brushCache.has(i)){const e=R["b"][i];this._brushCache.set(i,new e)}this._brushCache.get(i).drawMany(e,[t])}}var E=P;let D=class extends(Object(f["a"])(Object(d["a"])(_["a"]))){constructor(e){super(e)}initialize(){const e=u["p"].force512VTL?this.layer.tileInfo:this.layer.compatibleTileInfo256,t=this._getTileInfoSupportError(e,this.layer.fullExtent);if(t)return void this.addResolvingPromise(Promise.reject(t));const{basemapTerrain:i,spatialReference:n,pixelRatio:r}=this.view,s=Object(l["m"])(this.view,"basemapTerrain.tilingSchemeLocked").then(()=>{const e=i.tilingScheme,t=e.pixelSize;let r;this.schemaHelper=new c["a"](t,n.isGeographic),r=256===t?this.layer.compatibleTileInfo256:this.view.spatialReference.isGeographic?this.layer.compatibleTileInfo512:this.layer.tileInfo;const s=this._getTileInfoCompatibilityError(r,e);if(s)throw s;this._set("tileInfo",r)});this._tileHandlerController=Object(a["e"])();const{memoryController:o,scheduler:d}=this.view.resourceController;this._memCache=o.getMemCache(this.layer.uid,e=>e.release());const{style:f,spriteUrl:_,glyphsUrl:p}=this.layer.currentStyleInfo,m=new h["a"](f,{spriteUrl:_,glyphsUrl:p}),v=i.mapTileRequester;this.tileHandler=new L(this.layer,m,r,this._memCache,v);const g=this._tileHandlerController.signal,y=this.tileHandler.start({signal:g,scheduler:d}),b=this.tileHandler.spriteMosaic;b.then(e=>{!Object(a["o"])(g)&&this.tileHandler&&(this.painter=new E(e,this.tileHandler.glyphMosaic))}),y.then(()=>this._tileHandlerController=null);const w=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=Object(a["e"])(),this._memCache.clear();const{style:e,spriteUrl:t,glyphsUrl:i}=this.layer.currentStyleInfo,n=new h["a"](e,{spriteUrl:t,glyphsUrl:i}),s=new L(this.layer,n,r,this._memCache,v),o=s.start({signal:this._tileHandlerController.signal,scheduler:d}),l=s.spriteMosaic;o.then(()=>this._tileHandlerController=null),this.updatingHandles.addPromise(Promise.all([o,l]).then(([,e])=>{const t=this.tileHandler,i=this.painter;this.painter=new E(e,s.glyphMosaic),this.tileHandler=s,this.emit("data-changed"),t.destroy(),i&&i.dispose()}))};this.updatingHandles.add(this,"layer.currentStyleInfo",w),this.updatingHandles.add(this,"view.pixelRatio",w);const S=Promise.all([s,y,b]);this.addResolvingPromise(S)}destroy(){this.painter=Object(r["f"])(this.painter),this._tileHandlerController&&(this._tileHandlerController.abort(),this._tileHandlerController=null),Object(r["e"])(this.tileHandler),this._memCache=Object(r["e"])(this._memCache),this.tileHandler=null}get dataLevelRange(){const e=this.tileInfo.lods,t=e[0].scale,i=e[e.length-1].scale,n=this.levelRangeFromScaleRange(t,i);return 1===n.minLevel&&256===this.tileInfo.size[0]&&(n.minLevel=0),n}};Object(n["a"])([Object(s["b"])({aliasOf:"layer.fullExtent"})],D.prototype,"fullExtent",void 0),Object(n["a"])([Object(s["b"])()],D.prototype,"layer",void 0),Object(n["a"])([Object(s["b"])()],D.prototype,"tileInfo",void 0),Object(n["a"])([Object(s["b"])()],D.prototype,"dataLevelRange",null),Object(n["a"])([Object(s["b"])()],D.prototype,"updatingProgressValue",void 0),D=Object(n["a"])([Object(o["a"])("esri.views.3d.layers.VectorTileLayerView3D")],D);var z=D;t["default"]=z},d114:function(e,t,i){"use strict";i.d(t,"a",(function(){return s})),i.d(t,"b",(function(){return o})),i.d(t,"c",(function(){return r}));const n=new Float32Array(1);new Uint32Array(n.buffer);function r(e){return[255&e,(65280&e)>>>8,(16711680&e)>>>16,(4278190080&e)>>>24]}function s(e,t){return 65535&e|t<<16}function o(e,t,i,n){return 255&e|(255&t)<<8|(255&i)<<16|n<<24}},d5e4:function(e,t,i){"use strict";i.d(t,"a",(function(){return l}));var n=i("b2b2"),r=i("bc05");const s=32,o=8,a=64;class l{constructor(e,t,i){this.tileCoordRange=e,this._visibleTiles=t,this._createUnique=i,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return Object(n["j"])(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(e,t){this._uniqueSymbolLayerArray=null;let i=this._tiles.get(e.id);i||(i={symbols:new Map},this._tiles.set(e.id,i));const n=new Map;if(t)for(const r of t)i.symbols.has(r)&&(n.set(r,i.symbols.get(r)),i.symbols.delete(r));else for(const[r,s]of e.layerData)i.symbols.has(r)&&(n.set(r,i.symbols.get(r)),i.symbols.delete(r));this._removeSymbols(n);const l=e.symbols,c=new Map;for(const[h,u]of l){let e=u.length;if(e>=s){let t=this.tileCoordRange;do{t/=2,e/=4}while(e>o&&t>a);const n=new r["a"](this.tileCoordRange,this.tileCoordRange,t);c.set(h,{flat:u,index:n}),i.symbols.set(h,{flat:u,index:n});for(const e of u)n.getCell(e.xTile,e.yTile).push(e)}else c.set(h,{flat:u}),i.symbols.set(h,{flat:u})}this._addSymbols(e.key,l)}deleteStyleLayers(e){this._uniqueSymbolLayerArray=null;for(const[t,i]of this._tiles){const n=new Map;for(const t of e)i.symbols.has(t)&&(n.set(t,i.symbols.get(t)),i.symbols.delete(t));this._removeSymbols(n),0===i.symbols.size&&this._tiles.delete(t)}}removeTile(e){this._uniqueSymbolLayerArray=null;const t=this._tiles.get(e.id);if(!t)return;const i=new Map;for(const[n,r]of e.symbols)t.symbols.has(n)&&(i.set(n,t.symbols.get(n)),t.symbols.delete(n));this._removeSymbols(i),0===t.symbols.size&&this._tiles.delete(e.id)}_removeSymbols(e){for(const[t,{flat:i}]of e)for(const e of i){const i=e.unique,n=i.tileSymbols,r=n.length-1;for(let t=0;t<r;t++)if(n[t]===e){n[t]=n[r];break}if(n.length=r,0===r){const e=this._uniqueSymbolsReferences.get(t);e.delete(i),0===e.size&&this._uniqueSymbolsReferences.delete(t)}e.unique=null}}_addSymbols(e,t){if(0===t.size)return;const i=this._visibleTiles;for(const n of i)n.parentTile||n.key.world!==e.world||n.key.level===e.level&&!n.key.equals(e)||this._matchSymbols(n,e,t);for(const[r,s]of t)for(const e of s)if(Object(n["j"])(e.unique)){const t=this._createUnique();e.unique=t,t.tileSymbols.push(e);let i=this._uniqueSymbolsReferences.get(r);i||(i=new Set,this._uniqueSymbolsReferences.set(r,i)),i.add(t)}}_matchSymbols(e,t,i){if(e.key.level>t.level){const i=e.key.level-t.level;if(e.key.row>>i!==t.row||e.key.col>>i!==t.col)return}if(t.level>e.key.level){const i=t.level-e.key.level;if(t.row>>i!==e.key.row||t.col>>i!==e.key.col)return}if(t.equals(e.key)){for(const n of e.childrenTiles)this._matchSymbols(n,t,i);return}const s=new Map;for(const[o,a]of i){const i=[];for(const n of a){const s=Object(r["c"])(this.tileCoordRange,n.xTile,t.level,t.col,e.key.level,e.key.col),o=Object(r["c"])(this.tileCoordRange,n.yTile,t.level,t.row,e.key.level,e.key.row);s>=0&&s<this.tileCoordRange&&o>=0&&o<this.tileCoordRange&&i.push({symbol:n,xTransformed:s,yTransformed:o})}const l=[],c=e.key.level<t.level?1:1<<e.key.level-t.level,h=this._tiles.get(e.id).symbols.get(o);if(h){const e=h.flat;for(const t of i){let i,r=!1;const s=t.xTransformed,o=t.yTransformed;i=Object(n["k"])(h.index)?h.index.getCell(s,o):e;const a=t.symbol,u=a.hash;for(const e of i)if(u===e.hash&&Math.abs(s-e.xTile)<=c&&Math.abs(o-e.yTile)<=c){const t=e.unique;a.unique=t,t.tileSymbols.push(a),r=!0;break}r||l.push(a)}}l.length>0&&s.set(o,l)}for(const n of e.childrenTiles)this._matchSymbols(n,t,s)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsReferences,t=new Array(e.size);let i,n=0;for(const[r,s]of e){const e=new Array(s.size);i=0;for(const t of s)e[i++]=t;t[n]={styleLayerUID:r,uniqueSymbols:e},n++}return t}}}}]);